import { NextRequest, NextResponse } from "next/server";

const SEMANTIC_VIEW = "PHANTOM_IROPS.SEMANTIC_MODELS.IROPS_ANALYTICS";
const WAREHOUSE = "PHANTOM_IROPS_WH";

function getAccountUrl(): string {
  const account = process.env.SNOWFLAKE_ACCOUNT || "SFSENORTHAMERICA-SRSUBRAMANIAN_AWS1";
  const accountLower = account.toLowerCase().replace(/_/g, "-");
  return `https://${accountLower}.snowflakecomputing.com`;
}

interface AnalystMessage {
  role: "user" | "analyst";
  content: Array<{ type: string; text?: string; statement?: string; suggestions?: string[] }>;
}

async function executeSQL(sql: string, pat: string, accountUrl: string): Promise<Record<string, unknown>[]> {
  const cleanSql = sql.replace(/\s*--\s*Generated by Cortex Analyst.*$/m, "").trim();
  
  const response = await fetch(`${accountUrl}/api/v2/statements`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${pat}`,
    },
    body: JSON.stringify({
      statement: cleanSql,
      warehouse: WAREHOUSE,
      timeout: 60,
    }),
  });

  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`SQL execution failed: ${response.status} - ${errorText}`);
  }

  const data = await response.json();
  
  if (data.code && data.code !== "090001") {
    throw new Error(`SQL error: ${data.message}`);
  }

  const columns = data.resultSetMetaData?.rowType?.map((col: { name: string }) => col.name) || [];
  const rows = data.data || [];
  
  return rows.map((row: string[]) => {
    const obj: Record<string, unknown> = {};
    columns.forEach((col: string, i: number) => {
      obj[col] = row[i];
    });
    return obj;
  });
}

async function callCortexAnalyst(
  userMessage: string,
  history: AnalystMessage[]
): Promise<{ response: string; sql?: string; suggestions?: string[]; data?: Record<string, unknown>[] }> {
  const accountUrl = getAccountUrl();
  const pat = process.env.SNOWFLAKE_PASSWORD;

  if (!pat) {
    throw new Error("SNOWFLAKE_PASSWORD (PAT) not configured");
  }

  const messages: AnalystMessage[] = [
    ...history,
    {
      role: "user",
      content: [{ type: "text", text: userMessage }],
    },
  ];

  const response = await fetch(`${accountUrl}/api/v2/cortex/analyst/message`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${pat}`,
    },
    body: JSON.stringify({
      messages,
      semantic_view: SEMANTIC_VIEW,
    }),
  });

  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`Cortex Analyst call failed: ${response.status} - ${errorText}`);
  }

  const responseData = await response.json();
  const content = responseData.message?.content || [];

  let responseText = "";
  let sql: string | undefined;
  let suggestions: string[] | undefined;
  let queryData: Record<string, unknown>[] | undefined;

  for (const item of content) {
    if (item.type === "text" && item.text) {
      responseText += item.text + "\n";
    }
    if (item.type === "sql" && item.statement) {
      sql = item.statement;
    }
    if (item.type === "suggestions" && item.suggestions) {
      suggestions = item.suggestions;
    }
  }

  if (sql) {
    try {
      queryData = await executeSQL(sql, pat, accountUrl);
    } catch (err) {
      console.error("SQL execution error:", err);
    }
  }

  return {
    response: responseText.trim() || "No response from analyst",
    sql,
    suggestions,
    data: queryData,
  };
}

export async function POST(request: NextRequest) {
  try {
    const { message, history = [] } = await request.json();

    const result = await callCortexAnalyst(message, history);

    return NextResponse.json({
      response: result.response,
      sql: result.sql,
      suggestions: result.suggestions,
      data: result.data,
      timestamp: new Date().toISOString(),
    });
  } catch (error) {
    console.error("Intelligence API error:", error);
    return NextResponse.json(
      {
        response: `Error: ${(error as Error).message}`,
        error: true,
      },
      { status: 500 }
    );
  }
}
